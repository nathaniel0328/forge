local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local TweenService = game:GetService("TweenService")
local Workspace = game:GetService("Workspace")
local VirtualInputManager = game:GetService("VirtualInputManager")
local VirtualUser = game:GetService("VirtualUser") 
local GuiService = game:GetService("GuiService") 

local LocalPlayer = Players.LocalPlayer

_G.TheForgeLoaded = true 

local Config = {
    -- MINING
    AutoMine = false,
    SpinMining = false,
    MineTargets = {}, 
    PriorityList = {}, -- New Ordered List for Priority
    BreakNonPriority = false, 
    OreFilterEnabled = false,
    SelectedOres = {}, 
    AvoidOccupied = false,
    AvoidGoblinCave = false,
    SelectedZones = {},
    
    -- LAVA
    LavaDistanceSafe = 8,
    LavaDistanceUnsafe = 6,
    SpamLava = false, 
    
    -- COMBAT
    AutoFarmV2 = false,
    AutoFixShop = false, 
    AutoAttack = false,
    AutoParry = false,
    FightCloseMobs = false,
    AttackTargets = {},
    
    -- FORGE
    AutoHammer = false, 
    ForgeItemType = "Weapon",
    SelectedOre = "Iron",
    ForgeQty = 1,
    
    -- MISC
    AutoRun = false,
    InfiniteFly = false,
    ClickTeleport = false,
    AutoSell = false,
    SelectedSellItems = {} 
}

local AvailableOresList = {
    "Cobalt", "Titanium", "Lapis Lazuli", "Volcanic Rock", "Quartz", "Amethyst", 
    "Boneite", "Dark Boneite", "Topaz", "Diamond", "Sapphire", "Magenta Crystal", 
    "Crimson Crystal", "Blue Crystal", "Orange Crystal", "Green Crystal", "Obsidian", 
    "Emerald", "Ruby", "Rivalite", "Uranium", "Mythril", "Eye Ore", "Fireite", 
    "Magmaite", "Lightite", "Rainbow Crystal", "Demonite", "Darkryte", "Arcane Crystal",
    "Stone", "Sand Stone", "Copper", "Iron", "Gold", "Silver", "Tin", "Platinum", "Suryafal", "Etherealite", "Galestor", "Malachite", "Cryptex", "Crimsonite", "Aqujade", "Iceite", "Voidstar", "Gargantuan", "Heavenite"
}
table.sort(AvailableOresList)

local ScriptAPI = {}
local ActiveTargets = { Mining = nil, Combat = nil }
local IsTweening = false
local TWEEN_SPEED = 70 
local CurrentTweenTrack = nil 
local IsRespawning = false

-- Ignored Rocks Cache
local IgnoredRocks = {}

local LavaState = { IsSafe = true, LastHealth = 100, DamageTime = 0 }

-- Services
local KnitServices = ReplicatedStorage:WaitForChild("Shared", 5):WaitForChild("Packages", 5):WaitForChild("Knit", 5):WaitForChild("Services", 5)

local function GetServiceRemote(serviceName, remoteType, remoteName)
    local success, result = pcall(function()
        local service = KnitServices:WaitForChild(serviceName, 2)
        if service then
            local rf = service:WaitForChild("RF", 1)
            if rf then return rf:WaitForChild(remoteName, 1) end
        end
        return nil
    end)
    return result
end

local SellRemote = nil
pcall(function()
    SellRemote = ReplicatedStorage:WaitForChild("Shared", 10):WaitForChild("Packages", 10):WaitForChild("Knit", 10):WaitForChild("Services", 10):WaitForChild("DialogueService", 10):WaitForChild("RF", 10):WaitForChild("RunCommand", 10)
end)

local Remotes = {
    RedeemCode = GetServiceRemote("CodeService", "RF", "RedeemCode"),
    ToolActivated = GetServiceRemote("ToolService", "RF", "ToolActivated"),
    StartBlock = GetServiceRemote("ToolService", "RF", "StartBlock"),
    StopBlock = GetServiceRemote("ToolService", "RF", "StopBlock"),
    Run = GetServiceRemote("CharacterService", "RF", "Run"),
    ChangeSequence = GetServiceRemote("ForgeService", "RF", "ChangeSequence"),
    StartForge = GetServiceRemote("ForgeService", "RF", "StartForge"),
    Forge = GetServiceRemote("ProximityService", "RF", "Forge"),
    Reset = GetServiceRemote("CharacterService", "RF", "Reset") 
}

-- ═══════════════════════════════════════════════════════════════════════════
-- HELPER FUNCTIONS
-- ═══════════════════════════════════════════════════════════════════════════

local function GetInventoryData()
    local inventory = {}
    local playerGui = LocalPlayer:FindFirstChild("PlayerGui")
    local stash = playerGui and playerGui:FindFirstChild("Menu") and playerGui.Menu:FindFirstChild("Frame") and playerGui.Menu.Frame:FindFirstChild("Frame") and playerGui.Menu.Frame.Frame:FindFirstChild("Menus") and playerGui.Menu.Frame.Frame.Menus:FindFirstChild("Stash") and playerGui.Menu.Frame.Frame.Menus.Stash:FindFirstChild("Background")
    if stash then
        for _, itemFrame in ipairs(stash:GetChildren()) do
            if itemFrame:IsA("Frame") and itemFrame:FindFirstChild("Main") then
                local name = itemFrame.Main.ItemName.Text
                local qty = tonumber(itemFrame.Main.Quantity.Text:match("%d+")) or 0
                if name and qty > 0 then inventory[name:match("^%s*(.-)%s*$")] = qty end
            end
        end
    end
    return inventory
end

local function TweenCharacterTo(targetCFrame)
    local char = LocalPlayer.Character
    local root = char and char:FindFirstChild("HumanoidRootPart")
    if not root then return end
    
    local finalCFrame = targetCFrame - Vector3.new(0, 8, 0)
    if CurrentTweenTrack then task.cancel(CurrentTweenTrack) end
    
    CurrentTweenTrack = task.spawn(function()
        IsTweening = true
        local currentPos = root.Position
        local targetPos = finalCFrame.Position
        local distance = (targetPos - currentPos).Magnitude
        local time = distance / TWEEN_SPEED
        
        local tweenInfo = TweenInfo.new(time, Enum.EasingStyle.Linear)
        local tween = TweenService:Create(root, tweenInfo, {CFrame = finalCFrame})
        tween:Play()
        tween.Completed:Wait()
        IsTweening = false
    end)
end

local function InitializeNoclip()
    LocalPlayer.DevCameraOcclusionMode = Enum.DevCameraOcclusionMode.Invisicam
    RunService.Stepped:Connect(function()
        if Config.AutoMine or IsTweening or Config.AutoFarmV2 then
            local char = LocalPlayer.Character
            if char then
                for _, part in ipairs(char:GetDescendants()) do
                    if part:IsA("BasePart") and part.CanCollide then part.CanCollide = false end
                end
            end
        end
    end)
end

local function InitializeHealthMonitor()
    RunService.Heartbeat:Connect(function()
        local char = LocalPlayer.Character
        local hum = char and char:FindFirstChild("Humanoid")
        if hum then
            local currentHealth = hum.Health
            if currentHealth < LavaState.LastHealth then
                LavaState.IsSafe = false
                LavaState.DamageTime = tick()
            end
            LavaState.LastHealth = currentHealth
            if not LavaState.IsSafe and (tick() - LavaState.DamageTime > 1.0) then
                LavaState.IsSafe = true
            end
        end
    end)
end

local function FindCloseMob(range)
    local char = LocalPlayer.Character
    local root = char and char:FindFirstChild("HumanoidRootPart")
    if not root then return nil end
    local living = Workspace:FindFirstChild("Living")
    local closest, dist = nil, range
    if living then
        for _, mob in ipairs(living:GetChildren()) do
            if mob:IsA("Model") and mob:FindFirstChild("Humanoid") and mob.Humanoid.Health > 0 and mob:FindFirstChild("HumanoidRootPart") 
            and not mob:FindFirstChild("RaceFolder") and not Players:GetPlayerFromCharacter(mob) then
                 local d = (mob.HumanoidRootPart.Position - root.Position).Magnitude
                 if d < dist then dist = d; closest = mob end
            end
        end
    end
    return closest
end

-- ═══════════════════════════════════════════════════════════════════════════
-- AUTO MINE (REMODELED TO COMBAT V2 METHOD)
-- ═══════════════════════════════════════════════════════════════════════════
local function InitializeAutoMine()
    local CurrentMiningTarget = nil
    local MiningStartTime = 0 
    
    -- New Variables for Combat-Style TP
    local MINE_START_POS = Vector3.new(160.94, 112.08, 110.3) -- Using V2 Safe Spot
    local IsMiningRunning = false
    local CanMineTeleport = false
    local MineStartupTime = 0
    
    -- Spam Lava Logic Variables
    local LavaSpamState = { IsUp = true, LastSwitch = 0 }

    local function GetOresInRock(rockModel)
        local oresFound = {}
        for _, child in pairs(rockModel:GetChildren()) do
            local oreAttribute = child:GetAttribute("Ore")
            if oreAttribute then
                table.insert(oresFound, tostring(oreAttribute))
            end
        end
        return oresFound
    end

    local function ShouldContinueMining(rockModel)
        if not Config.OreFilterEnabled then return true end
        if #Config.SelectedOres == 0 then return true end

        local hpAttr = rockModel:GetAttribute("Health")
        local maxHpAttr = rockModel:GetAttribute("MaxHealth")
        
        if not hpAttr then
             local info = rockModel:FindFirstChild("infoFrame")
             if info and info.Frame.rockHP.Text then
                 local txt = info.Frame.rockHP.Text
                 local c, m = txt:match("(%d+)%s*/%s*(%d+)")
                 hpAttr = tonumber(c)
                 maxHpAttr = tonumber(m)
             end
        end

        if not hpAttr or not maxHpAttr then return true end
        
        local hpPercentage = (hpAttr / maxHpAttr) * 100
        if hpPercentage <= 60 then
            local oresInRock = GetOresInRock(rockModel)
            if #oresInRock == 0 then return true end 
            for _, foundOre in ipairs(oresInRock) do
                for _, desiredOre in ipairs(Config.SelectedOres) do
                    if foundOre == desiredOre then return true end
                end
            end
            return false
        end
        return true
    end

    local function IsOreOccupied(hitboxPart)
        if not Config.AvoidOccupied then return false end
        local rockModel = hitboxPart.Parent
        local myUsername = LocalPlayer.Name
        local lastHitPlayer = rockModel:GetAttribute("LastHitPlayer")
        
        local currentHP = rockModel:GetAttribute("Health") or 100
        local maxHP = rockModel:GetAttribute("MaxHealth") or 100
        
        if lastHitPlayer then
            if lastHitPlayer == myUsername then return false end
            if (currentHP / maxHP) * 100 >= 99 then return false end
            return true
        else
            if (currentHP / maxHP) * 100 < 99 then return true end
        end
        return false
    end

    ScriptAPI.GetRockTypes = function()
        local rockTypes = {}
        local seen = {}
        local rocksFolder = Workspace:FindFirstChild("Rocks")
        if rocksFolder then
            for _, category in ipairs(rocksFolder:GetChildren()) do
                for _, child in ipairs(category:GetChildren()) do
                    if child.Name == "SpawnLocation" then
                        for _, model in ipairs(child:GetChildren()) do
                            if model:IsA("Model") and model:FindFirstChild("Hitbox") and not seen[model.Name] then
                                seen[model.Name] = true; table.insert(rockTypes, model.Name)
                            end
                        end
                    elseif child:IsA("Model") and child:FindFirstChild("Hitbox") and not seen[child.Name] then
                        seen[child.Name] = true; table.insert(rockTypes, child.Name)
                    end
                end
            end
        end
        table.sort(rockTypes)
        return rockTypes
    end
    
    ScriptAPI.GetZoneNames = function()
        local zones = {}
        local rocksFolder = Workspace:FindFirstChild("Rocks")
        if rocksFolder then
            for _, folder in ipairs(rocksFolder:GetChildren()) do table.insert(zones, folder.Name) end
        end
        table.sort(zones)
        return zones
    end

    local function FindNearestRock(maxDist)
        local char = LocalPlayer.Character
        local root = char and char:FindFirstChild("HumanoidRootPart")
        if not root then return nil end
        
        local rocksFolder = Workspace:FindFirstChild("Rocks")
        if not rocksFolder then return nil end
        
        -- Prepare list of folders to scan
        local foldersToScan = {}
        if Config.SelectedZones and #Config.SelectedZones > 0 then
            for _, zoneName in ipairs(Config.SelectedZones) do
                local z = rocksFolder:FindFirstChild(zoneName)
                if z then table.insert(foldersToScan, z) end
            end
        else
            table.insert(foldersToScan, rocksFolder)
        end
        
        local goblinCaveFolder = rocksFolder:FindFirstChild("Island2GoblinCave")
        
        -- Priority Search: Check strictly in order (1st, 2nd, 3rd...)
        if #Config.PriorityList > 0 then
            for pIndex, priorityName in ipairs(Config.PriorityList) do
                local bestP, bestDist = nil, math.huge
                
                for _, scanRoot in ipairs(foldersToScan) do
                    for _, descendant in ipairs(scanRoot:GetDescendants()) do
                        if descendant.Name == "Hitbox" and descendant:IsA("BasePart") and descendant.Parent then
                            if descendant.Parent.Name == priorityName then
                                if IgnoredRocks[descendant] and (tick() - IgnoredRocks[descendant] < 5) then continue end
                                
                                local rockModel = descendant.Parent
                                local dist = (descendant.Position - root.Position).Magnitude
                                local isValid = true
                                
                                if IsOreOccupied(descendant) then isValid = false end
                                
                                local infoFrame = rockModel:FindFirstChild("infoFrame")
                                local hpText = infoFrame and infoFrame:FindFirstChild("Frame") and infoFrame.Frame:FindFirstChild("rockHP") and infoFrame.Frame.rockHP.Text
                                if hpText then
                                    local c = hpText:match("^(%d+)")
                                    if tonumber(c) and tonumber(c) <= 0 then isValid = false end
                                end
                                
                                if isValid and Config.AvoidGoblinCave and (#Config.SelectedZones == 0) and goblinCaveFolder and descendant:IsDescendantOf(goblinCaveFolder) then 
                                    isValid = false 
                                end
                                
                                if isValid and dist < bestDist then
                                    bestP = descendant
                                    bestDist = dist
                                end
                            end
                        end
                    end
                end
                
                if bestP then return bestP end -- Found highest priority, return immediately
            end
        end

        -- If no priority found (or none set), fallback to Targets/Filler
        local closestNormal, bestNormalDist = nil, math.huge
        
        for _, scanRoot in ipairs(foldersToScan) do
            for _, descendant in ipairs(scanRoot:GetDescendants()) do
                if descendant.Name == "Hitbox" and descendant:IsA("BasePart") and descendant.Parent then
                    if IgnoredRocks[descendant] and (tick() - IgnoredRocks[descendant] < 5) then continue end

                    local rockModel = descendant.Parent
                    local rockName = rockModel.Name
                    local dist = (descendant.Position - root.Position).Magnitude
                    local isValid = true
                    
                    if IsOreOccupied(descendant) then isValid = false end

                    local infoFrame = rockModel:FindFirstChild("infoFrame")
                    local hpText = infoFrame and infoFrame:FindFirstChild("Frame") and infoFrame.Frame:FindFirstChild("rockHP") and infoFrame.Frame.rockHP.Text
                    if hpText then
                        local c = hpText:match("^(%d+)")
                        if tonumber(c) and tonumber(c) <= 0 then isValid = false end
                    end

                    if isValid and Config.AvoidGoblinCave and (#Config.SelectedZones == 0) and goblinCaveFolder and descendant:IsDescendantOf(goblinCaveFolder) then 
                        isValid = false 
                    end

                    if isValid then
                        local isTarget = Config.MineTargets[rockName]
                        local isBreakNonPriority = Config.BreakNonPriority 
                        
                        -- Exclude active Priorities from "BreakNonPriority" check to avoid re-checking them messily, 
                        -- though logic handles it.
                        if isTarget or isBreakNonPriority then
                            if dist < bestNormalDist then
                                closestNormal = descendant
                                bestNormalDist = dist
                            end
                        end
                    end
                end
            end
        end
        return closestNormal
    end

    -- Loop for Reset Logic (Combat V2 Style)
    task.spawn(function()
        while true do
            if Config.AutoMine then
                pcall(function() 
                    if Remotes.Reset then Remotes.Reset:InvokeServer() end
                end)
                task.wait(4) 
            else
                task.wait(1)
            end
        end
    end)

    -- Loop for Target Finding & Attack
    task.spawn(function()
        while true do
            task.wait(0.1)
            local char = LocalPlayer.Character
            local root = char and char:FindFirstChild("HumanoidRootPart")
            local humanoid = char and char:FindFirstChild("Humanoid")
            
            if Config.AutoMine and Remotes.ToolActivated and root and humanoid then
                
                if Config.FightCloseMobs then
                    local closeMob = FindCloseMob(20)
                    if closeMob then ActiveTargets.Combat = closeMob else if not Config.AutoAttack then ActiveTargets.Combat = nil end end
                end

                if not ActiveTargets.Combat then
                    local pickaxe = char:FindFirstChild("Pickaxe")
                    if not pickaxe then
                        local bp = LocalPlayer.Backpack:FindFirstChild("Pickaxe")
                        if bp then humanoid:EquipTool(bp); pickaxe = bp end
                    end

                    local targetValid = false
                    if ActiveTargets.Mining and ActiveTargets.Mining.Parent then
                         local rockModel = ActiveTargets.Mining.Parent
                         
                         local info = rockModel:FindFirstChild("infoFrame")
                         local hp = 100
                         if info and info.Frame.rockHP.Text then
                            local c = info.Frame.rockHP.Text:match("^(%d+)")
                            hp = tonumber(c) or 0
                            if hp > 0 then targetValid = true end
                         end
                         
                         if targetValid and Config.OreFilterEnabled then
                             -- Logic: Check if current target is in priority list
                             local isPriority = false
                             for _, pName in ipairs(Config.PriorityList) do
                                 if rockModel.Name == pName then isPriority = true; break end
                             end
                             
                             if Config.BreakNonPriority and not isPriority then
                                 -- Ignore filter, break it
                             else
                                 if not ShouldContinueMining(rockModel) then
                                     targetValid = false
                                     IgnoredRocks[ActiveTargets.Mining] = tick()
                                     print("❌ [Filter] Skipped rock")
                                 end
                             end
                         end
                    end
                    
                    if targetValid and ActiveTargets.Mining then
                        if ActiveTargets.Mining ~= CurrentMiningTarget then
                            CurrentMiningTarget = ActiveTargets.Mining
                            MiningStartTime = tick()
                        else
                            if targetValid and (tick() - MiningStartTime > 3) then
                                local rockModel = ActiveTargets.Mining.Parent
                                local lastHit = rockModel:GetAttribute("LastHitPlayer")
                                if lastHit and lastHit ~= LocalPlayer.Name then
                                    IgnoredRocks[ActiveTargets.Mining] = tick()
                                    ActiveTargets.Mining = nil
                                    targetValid = false
                                    CurrentMiningTarget = nil
                                end
                            end
                        end
                    else
                        CurrentMiningTarget = nil
                    end

                    if not targetValid then ActiveTargets.Mining = nil end
                    
                    if not ActiveTargets.Mining then 
                        ActiveTargets.Mining = FindNearestRock(math.huge)
                        if ActiveTargets.Mining then MiningStartTime = tick() end
                    end

                    -- Clicker logic (Only if close enough)
                    if pickaxe and ActiveTargets.Mining and ActiveTargets.Mining.Parent then
                         local dist = (root.Position - ActiveTargets.Mining.Position).Magnitude
                         -- Allow slightly larger distance for click due to lag/tp
                         if dist <= 30 then Remotes.ToolActivated:InvokeServer("Pickaxe") end
                    end
                end
            else
                ActiveTargets.Mining = nil
            end
        end
    end)

    -- New Heartbeat (Combat TP Method + Spam Logic)
    RunService.Heartbeat:Connect(function(dt)
        if not Config.AutoMine then 
            IsMiningRunning = false
            CanMineTeleport = false
            return 
        end

        if not IsMiningRunning then
            IsMiningRunning = true
            MineStartupTime = tick()
            CanMineTeleport = false
            
            pcall(function() if Remotes.Reset then Remotes.Reset:InvokeServer() end end)
        end

        local char = LocalPlayer.Character
        local root = char and char:FindFirstChild("HumanoidRootPart")
        if not root then return end
        
        -- Delay Sequence: Safe Spot -> Mine
        if not CanMineTeleport then
            if tick() - MineStartupTime >= 5.5 then
                CanMineTeleport = true
            else
                root.CFrame = CFrame.new(MINE_START_POS)
                root.AssemblyLinearVelocity = Vector3.zero
                root.AssemblyAngularVelocity = Vector3.zero
                return
            end
        end

        if ActiveTargets.Mining and not ActiveTargets.Combat and ActiveTargets.Mining.Parent then
            root.Anchored = false
            root.AssemblyLinearVelocity = Vector3.zero
            root.AssemblyAngularVelocity = Vector3.zero
            
            local targetPos = ActiveTargets.Mining.Position
            local verticalOffset
            
            -- Spam Lava Logic (Up/Down)
            if Config.SpamLava then
                if tick() - LavaSpamState.LastSwitch >= 0.5 then
                    LavaSpamState.IsUp = not LavaSpamState.IsUp
                    LavaSpamState.LastSwitch = tick()
                end
                
                -- IsUp = Higher Position (Unsafe Val is usually higher, e.g. -6 vs -8)
                -- Using LavaDistanceSafe (8) and LavaDistanceUnsafe (6)
                if LavaSpamState.IsUp then
                    verticalOffset = Config.LavaDistanceUnsafe -- Closer/Higher
                else
                    verticalOffset = Config.LavaDistanceSafe -- Lower
                end
            else
                -- Standard Logic
                verticalOffset = LavaState.IsSafe and Config.LavaDistanceSafe or Config.LavaDistanceUnsafe
            end
            
            local idealPos = targetPos - Vector3.new(0, verticalOffset, 0)
            
            -- Instant TP (Combat Style)
            local rotation
            if Config.SpinMining then
                rotation = CFrame.Angles(0, tick() * 15, 0) 
            else
                rotation = CFrame.lookAt(idealPos, targetPos).Rotation
            end
            
            root.CFrame = CFrame.new(idealPos) * rotation
        elseif not ActiveTargets.Mining then
            -- If no target, go to safe spot
            root.CFrame = CFrame.new(MINE_START_POS)
            root.AssemblyLinearVelocity = Vector3.zero
        end
    end)
end

-- ═══════════════════════════════════════════════════════════════════════════
-- AUTO FARM V2 + SHOP FIX
-- ═══════════════════════════════════════════════════════════════════════════
local function InitializeAutoFarmV2()
    local FARM_START_POS = Vector3.new(160.94, 112.08, 110.3)
    local MERCHANT_POS = Vector3.new(-141.40, 21.56, -26.53)
    
    local IsRunning = false
    local HasVisitedMerchant = false
    local CanTeleport = false
    local FarmStartTime = 0
    local LastV2Attack = 0
    
    local LastTargetMob = nil
    local MobAttackStartTime = 0
    local IsV2Above = true
    
    task.spawn(function()
        while true do
            if Config.AutoFarmV2 then
                pcall(function() 
                    if Remotes.Reset then Remotes.Reset:InvokeServer() end
                end)
                task.wait(4) 
            else
                task.wait(1)
            end
        end
    end)

    RunService.Heartbeat:Connect(function()
        if not Config.AutoFarmV2 then 
            IsRunning = false
            CanTeleport = false
            LastTargetMob = nil
            return 
        end

        if not IsRunning then
            IsRunning = true
            FarmStartTime = tick()
            CanTeleport = false
            
            pcall(function() if Remotes.Reset then Remotes.Reset:InvokeServer() end end)
            
            if Config.AutoFixShop and not HasVisitedMerchant then
                task.spawn(function()
                    task.wait(2)
                    local char = LocalPlayer.Character
                    local root = char and char:FindFirstChild("HumanoidRootPart")
                    if root then
                        root.CFrame = CFrame.new(MERCHANT_POS)
                        for i=1, 20 do
                            VirtualInputManager:SendKeyEvent(true, Enum.KeyCode.E, false, game)
                            task.wait(0.05)
                            VirtualInputManager:SendKeyEvent(false, Enum.KeyCode.E, false, game)
                        end
                        HasVisitedMerchant = true
                    end
                end)
            end
        end

        local char = LocalPlayer.Character
        local root = char and char:FindFirstChild("HumanoidRootPart")
        local humanoid = char and char:FindFirstChild("Humanoid")
        if not root or not humanoid then return end
        
        if not CanTeleport then
            if tick() - FarmStartTime >= 5.5 then
                CanTeleport = true
            else
                root.CFrame = CFrame.new(FARM_START_POS)
                root.AssemblyLinearVelocity = Vector3.zero
                root.AssemblyAngularVelocity = Vector3.zero
                return
            end
        end

        local target = nil
        local living = Workspace:FindFirstChild("Living")
        if living then
            for _, mob in ipairs(living:GetChildren()) do
                if mob:FindFirstChild("Humanoid") and mob.Humanoid.Health > 0 and mob:FindFirstChild("HumanoidRootPart") and not Players:GetPlayerFromCharacter(mob) then
                     local cleanName = mob.Name:gsub("%d+$", "")
                     if Config.AttackTargets[cleanName] then
                         target = mob
                         break
                     end
                end
            end
        end

        if target then
            local tRoot = target.HumanoidRootPart
            local tPos = tRoot.Position
            
            if target ~= LastTargetMob then
                LastTargetMob = target
                MobAttackStartTime = tick()
                IsV2Above = true
            else
                if IsV2Above and (tick() - MobAttackStartTime > 5) then
                    IsV2Above = false
                end
            end

            local offset = IsV2Above and Vector3.new(0, 7, 0) or Vector3.new(0, -9, 0)
            local lockPos = tPos + offset

            root.CFrame = CFrame.new(lockPos, tPos)
            
            local weapon = char:FindFirstChildWhichIsA("Tool")
            if not weapon then
                local bpWeapon = LocalPlayer.Backpack:FindFirstChildWhichIsA("Tool")
                if bpWeapon then humanoid:EquipTool(bpWeapon) end
            end

            if (root.Position - tPos).Magnitude < 15 then
                if tick() - LastV2Attack > 0.05 then
                    task.spawn(function()
                        pcall(function() 
                            if Remotes.ToolActivated then Remotes.ToolActivated:InvokeServer("Weapon") end 
                        end)
                    end)
                    LastV2Attack = tick()
                end
            end
        else
            root.CFrame = CFrame.new(FARM_START_POS)
            LastTargetMob = nil
        end
        
        root.AssemblyLinearVelocity = Vector3.zero
        root.AssemblyAngularVelocity = Vector3.zero
    end)
end

-- ═══════════════════════════════════════════════════════════════════════════
-- STANDARD COMBAT
-- ═══════════════════════════════════════════════════════════════════════════
local function InitializeCombat()
    local CurrentTarget = nil
    local IsAbove = true
    local LastPositionSwitch = 0
    local LastAttackTime = 0
    local IsBlocking = false

    ScriptAPI.GetMobTypes = function()
        local mobs = {}
        local seen = {}
        local living = Workspace:FindFirstChild("Living")
        if living then
            for _, model in ipairs(living:GetChildren()) do
                if model:IsA("Model") and model:FindFirstChild("Humanoid") and not model:FindFirstChild("RaceFolder") and not Players:GetPlayerFromCharacter(model) then
                    local name = model.Name:gsub("%d+$", "")
                    if not seen[name] then seen[name] = true; table.insert(mobs, name) end
                end
            end
        end
        table.sort(mobs)
        return mobs
    end

    local function IsMobValid(mob)
        return mob and mob.Parent and mob:FindFirstChild("Humanoid") and mob.Humanoid.Health > 0 and mob:FindFirstChild("HumanoidRootPart")
    end

    local function FindStandardTarget()
        local char = LocalPlayer.Character
        local root = char and char:FindFirstChild("HumanoidRootPart")
        if not root then return nil end

        if Config.FightCloseMobs then
            local closeMob = FindCloseMob(25)
            if closeMob then return closeMob end
        end

        if Config.AutoAttack then
            local living = Workspace:FindFirstChild("Living")
            local bestTarget, bestDist = nil, 2000 
            if living then
                for _, mob in ipairs(living:GetChildren()) do
                    if IsMobValid(mob) and not Players:GetPlayerFromCharacter(mob) then
                        local cleanName = mob.Name:gsub("%d+$", "")
                        if Config.AttackTargets and Config.AttackTargets[cleanName] then
                            local dist = (mob.HumanoidRootPart.Position - root.Position).Magnitude
                            if dist < bestDist then bestTarget = mob; bestDist = dist end
                        end
                    end
                end
            end
            return bestTarget
        end
        return nil
    end

    RunService.Heartbeat:Connect(function()
        if Config.AutoFarmV2 or IsRespawning then return end

        local char = LocalPlayer.Character
        local root = char and char:FindFirstChild("HumanoidRootPart")
        local humanoid = char and char:FindFirstChild("Humanoid")

        if not root or not humanoid or humanoid.Health <= 0 then return end

        if CurrentTarget and not IsMobValid(CurrentTarget) then CurrentTarget = nil end
        if not CurrentTarget then CurrentTarget = FindStandardTarget() end

        ActiveTargets.Combat = CurrentTarget

        if CurrentTarget then
            local targetRoot = CurrentTarget.HumanoidRootPart
            local targetPos = targetRoot.Position

            if tick() - LastPositionSwitch > 3 then
                IsAbove = not IsAbove
                LastPositionSwitch = tick()
            end

            local lockCFrame = IsAbove and CFrame.new(targetPos + Vector3.new(0, 7, 0), targetPos) or CFrame.new(targetPos - Vector3.new(0, 8, 0), targetPos)
            root.CFrame = lockCFrame
            root.AssemblyLinearVelocity = Vector3.zero
            root.AssemblyAngularVelocity = Vector3.zero

            local weapon = char:FindFirstChildWhichIsA("Tool")
            if not weapon then
                local bpWeapon = LocalPlayer.Backpack:FindFirstChildWhichIsA("Tool")
                if bpWeapon then humanoid:EquipTool(bpWeapon); weapon = bpWeapon end
            end

            if tick() - LastAttackTime > 0.25 then
                if Remotes.ToolActivated then Remotes.ToolActivated:InvokeServer("Weapon") elseif weapon then weapon:Activate() end
                LastAttackTime = tick()
            end

            if Config.AutoParry then
                local status = CurrentTarget:FindFirstChild("Status")
                local isMobAttacking = status and status:FindFirstChild("Attacking") and status.Attacking.Value == true
                if isMobAttacking then
                    if not IsBlocking then if Remotes.StartBlock then Remotes.StartBlock:InvokeServer() end; IsBlocking = true end
                else
                    if IsBlocking then if Remotes.StopBlock then Remotes.StopBlock:InvokeServer() end; IsBlocking = false end
                end
            end
        else
            if IsBlocking then if Remotes.StopBlock then Remotes.StopBlock:InvokeServer() end; IsBlocking = false end
        end
    end)
end

-- ═══════════════════════════════════════════════════════════════════════════
-- FORGE, HAMMER & SELL
-- ═══════════════════════════════════════════════════════════════════════════
local function InitializeForgeAndSell()
    -- AUTO HAMMER MINIGAME
    local ForgeGUI = LocalPlayer.PlayerGui:WaitForChild("Forge", 5)
    if ForgeGUI then
        local HammerGame = ForgeGUI:WaitForChild("HammerMinigame", 5)
        if HammerGame then
            HammerGame.ChildAdded:Connect(function(Button)
                if Button:IsA("TextButton") and Config.AutoHammer then
                    local Frame = Button:WaitForChild("Frame")
                    local Border = Frame:WaitForChild("Border")
                    local Circle = Frame:WaitForChild("Circle")
                    local Connection
                    Connection = RunService.RenderStepped:Connect(function()
                        if Button and Button.Parent and Frame and Border and Circle then
                            if math.abs(Border.AbsoluteSize.X - Circle.AbsoluteSize.X) <= 20 and math.abs(Border.AbsoluteSize.Y - Circle.AbsoluteSize.Y) <= 20 then
                                local PosX = Button.AbsolutePosition.X + Button.AbsoluteSize.X / 2
                                local PosY = Button.AbsolutePosition.Y + Button.AbsoluteSize.Y / 2 + GuiService:GetGuiInset().Y
                                VirtualInputManager:SendMouseButtonEvent(PosX, PosY, 0, true, game, 0)
                                task.wait(0.05)
                                VirtualInputManager:SendMouseButtonEvent(PosX, PosY, 0, false, game, 0)
                                Connection:Disconnect()
                            end
                        else
                            Connection:Disconnect()
                        end
                    end)
                end
            end)
        end
    end

    local function ManualMeltAndPour(notifyFunc)
        local forgeModel = Workspace:WaitForChild("Proximity", 5) and Workspace.Proximity:WaitForChild("Forge", 5)
        if not Remotes.StartForge or not forgeModel then return end
        
        local av = GetInventoryData()
        local use = math.min(Config.ForgeQty, av[Config.SelectedOre] or 0)
        
        if use <= 0 then
            if notifyFunc then notifyFunc("Error", "Not enough ores! Check inventory.", 3) end
            return
        end
        
        local ores = {[Config.SelectedOre] = use}
        local itemType = Config.ForgeItemType
        
        if notifyFunc then notifyFunc("Forge", "Starting Melt & Pour...", 3) end
        
        Remotes.Forge:InvokeServer(forgeModel); task.wait(0.2)
        Remotes.StartForge:InvokeServer(forgeModel)
        
        TweenCharacterTo(forgeModel.Smelter.CFrame); task.wait(1)
        Remotes.ChangeSequence:InvokeServer(unpack({"Melt", {FastForge = false, ItemType = itemType, Ores = ores}}))
        task.wait(5.5)

        Remotes.ChangeSequence:InvokeServer("Pour", { ClientTime = Workspace:GetServerTimeNow() })
        task.wait(4.5)

        TweenCharacterTo(forgeModel.Anvil.CFrame); task.wait(1)
        Remotes.ChangeSequence:InvokeServer("Hammer", { ClientTime = Workspace:GetServerTimeNow() })
        
        if notifyFunc then notifyFunc("Forge", "Ready to Hammer!", 3) end
    end

    local function GenuineForge(ores, itemType, notifyFunc)
        local forgeModel = Workspace:WaitForChild("Proximity", 5) and Workspace.Proximity:WaitForChild("Forge", 5)
        if not Remotes.StartForge or not forgeModel then return end
        if not itemType then itemType = "Weapon" end
        
        if notifyFunc then notifyFunc("Forge", "Starting Forge...") end
        Remotes.Forge:InvokeServer(forgeModel); task.wait(0.2)
        Remotes.StartForge:InvokeServer(forgeModel)
        TweenCharacterTo(forgeModel.Smelter.CFrame); task.wait(1)
        Remotes.ChangeSequence:InvokeServer(unpack({"Melt", {FastForge = false, ItemType = itemType, Ores = ores}}))
        task.wait(5.5)
        Remotes.ChangeSequence:InvokeServer("Pour", { ClientTime = Workspace:GetServerTimeNow() })
        task.wait(4.5)
        TweenCharacterTo(forgeModel.Anvil.CFrame); task.wait(1)
        Remotes.ChangeSequence:InvokeServer("Hammer", { ClientTime = Workspace:GetServerTimeNow() })
        for i = 1, 6 do Remotes.ToolActivated:InvokeServer("Hammer"); task.wait(0.6) end
        TweenCharacterTo(forgeModel.Trough.CFrame); task.wait(1)
        task.spawn(function() Remotes.ChangeSequence:InvokeServer("Water", { ClientTime = Workspace:GetServerTimeNow() }) end)
        task.wait(2)
        Remotes.ChangeSequence:InvokeServer("Showcase", {})
        if notifyFunc then notifyFunc("Forge", "Completed!") end
    end

    local function GetPlayerMoney()
        local playerGui = LocalPlayer:FindFirstChild("PlayerGui")
        if not playerGui then return "N/A" end
        local possibleLocations = { playerGui:FindFirstChild("Menu") and playerGui.Menu:FindFirstChild("Frame") and playerGui.Menu.Frame:FindFirstChild("Frame"), playerGui:FindFirstChild("HUD"), playerGui:FindFirstChild("Main") }
        for _, gui in ipairs(possibleLocations) do
            if gui then
                for _, descendant in ipairs(gui:GetDescendants()) do
                    if (descendant:IsA("TextLabel") or descendant:IsA("TextBox")) then
                        local text = descendant.Text
                        if text:find("%$") or text:lower():find("money") or text:lower():find("cash") or text:lower():find("gold") then return text end
                    end
                end
            end
        end
        return "Unknown"
    end

    local function TalkToSeller()
        local SELLER_POSITION = Vector3.new(-141.95, 21.30, -27.09)
        local char = LocalPlayer.Character
        local root = char and char:FindFirstChild("HumanoidRootPart")
        if not root then return false end
        local oldPos = root.CFrame
        root.CFrame = CFrame.new(SELLER_POSITION)
        task.wait(0.5)
        local prompt = Workspace.Proximity["Greedy Cey"].ProximityPrompt
        if prompt then
            fireproximityprompt(prompt); task.wait(0.5)
            pcall(function()
                VirtualInputManager:SendMouseButtonEvent(1200, 498, 0, true, game, 1); task.wait(0.01)
                VirtualInputManager:SendMouseButtonEvent(1200, 498, 0, false, game, 1)
            end)
            task.wait(0.3); root.CFrame = oldPos; return true
        end
        return false
    end

    ScriptAPI.GenuineForge = GenuineForge
    ScriptAPI.ManualMeltAndPour = ManualMeltAndPour
    ScriptAPI.GetAvailableOres = GetInventoryData
    ScriptAPI.TalkToSeller = TalkToSeller
    ScriptAPI.GetPlayerMoney = GetPlayerMoney

    -- UPDATED AUTO SELL LOOP
    task.spawn(function()
        while true do
            task.wait(2)
            if Config.AutoSell and SellRemote then
                local inventory = GetInventoryData()
                local basket = {}
                for itemName, isEnabled in pairs(Config.SelectedSellItems) do
                    if isEnabled then
                        local qty = inventory[itemName] or 0
                        if qty > 0 then basket[itemName] = qty end
                    end
                end
                if next(basket) then
                    SellRemote:InvokeServer("SellConfirm", {Basket = basket})
                end
            end
        end
    end)
end

local function InitializeMovement()
    UserInputService.InputBegan:Connect(function(input, gameProcessed)
        if gameProcessed then return end
        if Config.ClickTeleport and input.UserInputType == Enum.UserInputType.MouseButton1 and UserInputService:IsKeyDown(Enum.KeyCode.LeftControl) then
            local mouse = LocalPlayer:GetMouse()
            if mouse.Hit then TweenCharacterTo(CFrame.new(mouse.Hit.Position)) end
        end
    end)

    local bg, bv, flying = nil, nil, false
    local function stopFly()
        flying = false
        if bg then bg:Destroy(); bg = nil end
        if bv then bv:Destroy(); bv = nil end
        if LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("Humanoid") then LocalPlayer.Character.Humanoid.PlatformStand = false end
    end
    local function startFly()
        local char = LocalPlayer.Character
        local root = char and char:FindFirstChild("HumanoidRootPart")
        if not root then return end
        flying = true
        char.Humanoid.PlatformStand = true
        bg = Instance.new("BodyGyro", root); bg.P = 90000; bg.maxTorque = Vector3.new(9e9, 9e9, 9e9); bg.cframe = root.CFrame
        bv = Instance.new("BodyVelocity", root); bv.velocity = Vector3.zero; bv.maxForce = Vector3.new(9e9, 9e9, 9e9)
        task.spawn(function()
            while flying do
                local cam = Workspace.CurrentCamera
                local direction = Vector3.zero
                if UserInputService:IsKeyDown(Enum.KeyCode.W) then direction = direction + cam.CFrame.LookVector end
                if UserInputService:IsKeyDown(Enum.KeyCode.S) then direction = direction - cam.CFrame.LookVector end
                if UserInputService:IsKeyDown(Enum.KeyCode.A) then direction = direction - cam.CFrame.RightVector end
                if UserInputService:IsKeyDown(Enum.KeyCode.D) then direction = direction + cam.CFrame.RightVector end
                if direction.Magnitude > 0 then bv.velocity = direction.Unit * 50 else bv.velocity = Vector3.zero end
                bg.cframe = cam.CFrame
                RunService.RenderStepped:Wait()
            end
            stopFly()
        end)
    end
    task.spawn(function()
        while true do
            task.wait(0.2)
            if Config.InfiniteFly then if not flying then startFly() end else if flying then stopFly() end end
        end
    end)
    LocalPlayer.CharacterAdded:Connect(function() if flying then stopFly() end end)
end

local function RedeemAllCodes()
    for _, code in ipairs({"XMAS!", "SORRYFORDELAY"}) do
        task.spawn(function() Remotes.RedeemCode:InvokeServer(code) end); task.wait(0.2)
    end
end

-- -----------------------------------------------------------------------------
-- RESPAWN & START
-- -----------------------------------------------------------------------------
local function InitializeRespawnHandler()
    LocalPlayer.CharacterAdded:Connect(function(char)
        IsRespawning = true
        local hum = char:WaitForChild("Humanoid", 5)
        task.wait(0.5) 
        if Config.AutoAttack or Config.AutoFarmV2 then
            local backpack = LocalPlayer:FindFirstChild("Backpack")
            if backpack and hum then
                local weapon = backpack:FindFirstChildWhichIsA("Tool")
                if weapon then hum:EquipTool(weapon) end
            end
        end
        IsRespawning = false
    end)
end

pcall(function()
    if LocalPlayer then
        LocalPlayer.Idled:Connect(function()
            if VirtualUser then
                VirtualUser:CaptureController()
                VirtualUser:ClickButton2(Vector2.new())
            end
        end)
    end
end)

-- Initialize Systems
InitializeHealthMonitor() 
InitializeNoclip()
InitializeAutoMine()
InitializeForgeAndSell()
InitializeMovement()
InitializeRespawnHandler()
InitializeCombat()
InitializeAutoFarmV2()

-- ═══════════════════════════════════════════════════════════════════════════
-- RAYFIELD UI
-- ═══════════════════════════════════════════════════════════════════════════
local Rayfield = loadstring(game:HttpGet('https://sirius.menu/rayfield'))()
local Window = Rayfield:CreateWindow({Name = "The Forge (Complete + Melt)", LoadingTitle = "", LoadingSubtitle = "", ConfigurationSaving = {Enabled = true, FolderName = "TheForgeScript", FileName = "Config"}, KeySystem = false, Theme = "Ocean"})

local FarmingTab = Window:CreateTab("Farming", 4483362458)
local CombatTab = Window:CreateTab("Combat", 4483362458)
local SellingTab = Window:CreateTab("Selling", 4483362458)
local ForgeTab = Window:CreateTab("Forge", 4483362458)
local TeleportTab = Window:CreateTab("Teleport", 4483362458)
local MiscTab = Window:CreateTab("Misc", 4483362458)

-- FARMING SECTION
FarmingTab:CreateSection("Auto Mine")
FarmingTab:CreateToggle({Name = "Enabled", CurrentValue = false, Flag = "AutoMine", Callback = function(v) Config.AutoMine = v end})

FarmingTab:CreateSection("Target Selection")
-- Priority Logic
local PriorityLabel = FarmingTab:CreateParagraph({Title = "Current Priority Queue", Content = "None selected"})

local PriorityDropdown
PriorityDropdown = FarmingTab:CreateDropdown({
    Name = "Priority Ores (Order Matters!)", 
    Options = {"Loading..."}, 
    CurrentOption = {},
    MultipleOptions = true,
    Flag = "PriorityOresMulti",
    Callback = function(selected)
        -- Ordered Logic: Compare new selection with saved Config.PriorityList
        -- Rayfield sends 'selected' as a table, likely sorted alphabetically or by index, not click order.
        -- We must deduce click order.
        
        -- 1. Check for removed items
        for i = #Config.PriorityList, 1, -1 do
            local item = Config.PriorityList[i]
            local found = false
            for _, s in ipairs(selected) do
                if s == item then found = true; break end
            end
            if not found then
                table.remove(Config.PriorityList, i)
            end
        end
        
        -- 2. Check for added items
        for _, s in ipairs(selected) do
            local found = false
            for _, item in ipairs(Config.PriorityList) do
                if item == s then found = true; break end
            end
            if not found then
                table.insert(Config.PriorityList, s)
            end
        end
        
        -- Update UI Label
        if #Config.PriorityList == 0 then
            PriorityLabel:Set({Title = "Current Priority Queue", Content = "None selected"})
        else
            local txt = ""
            for i, p in ipairs(Config.PriorityList) do
                txt = txt .. i .. ". " .. p .. "  >  "
            end
            PriorityLabel:Set({Title = "Current Priority Queue", Content = txt:sub(1, -6)})
        end
    end
})

FarmingTab:CreateToggle({Name = "Break Non-Priority Rocks (Spawn Help)", CurrentValue = false, Flag = "BreakNonPriority", Callback = function(v) Config.BreakNonPriority = v end})

-- Dynamic Rock Toggles
local RockToggles, SeenRocks = {}, {}
task.spawn(function()
    while true do
        if ScriptAPI.GetRockTypes then
            local newRocks, needsRefresh = ScriptAPI.GetRockTypes(), false
            for _, r in ipairs(newRocks) do
                if not SeenRocks[r] then
                    SeenRocks[r] = true; needsRefresh = true
                    FarmingTab:CreateToggle({Name = "Mine: "..r, CurrentValue = false, Flag = "Rock_"..r, Callback = function(v) Config.MineTargets[r] = v end})
                end
            end
            if needsRefresh then
                local opts = {}; for k in pairs(SeenRocks) do table.insert(opts, k) end; table.sort(opts)
                PriorityDropdown:Refresh(opts)
            end
        end
        task.wait(5)
    end
end)

FarmingTab:CreateSection("Ore Filter (Optional)")
FarmingTab:CreateLabel("Enable this only if you want to scan contents.")
FarmingTab:CreateLabel("Leave OFF for standard mining.")
FarmingTab:CreateToggle({Name = "Enable Ore Filter", CurrentValue = false, Flag = "OreFilter", Callback = function(v) Config.OreFilterEnabled = v end})
FarmingTab:CreateDropdown({
    Name = "Select Wanted Drops",
    Options = AvailableOresList,
    CurrentOption = {},
    MultipleOptions = true,
    Flag = "SelectedOres",
    Callback = function(options)
        Config.SelectedOres = options
    end
})

FarmingTab:CreateSection("Smart Lava Logic")
FarmingTab:CreateToggle({Name = "Spam Lava (Up/Down 0.5s)", CurrentValue = false, Flag = "SpamLava", Callback = function(v) Config.SpamLava = v end})
FarmingTab:CreateLabel("Detection: Health Drop")
FarmingTab:CreateSlider({Name = "Safe Distance", Range = {6, 15}, Increment = 1, CurrentValue = 8, Flag = "SafeDist", Callback = function(v) Config.LavaDistanceSafe = v end})
FarmingTab:CreateSlider({Name = "Lava Distance", Range = {4, 10}, Increment = 1, CurrentValue = 6, Flag = "LavaDist", Callback = function(v) Config.LavaDistanceUnsafe = v end})

FarmingTab:CreateSection("Extras")
FarmingTab:CreateToggle({Name = "Spin While Mining", CurrentValue = false, Flag = "SpinMining", Callback = function(v) Config.SpinMining = v end})
FarmingTab:CreateToggle({Name = "Avoid Occupied Ores", CurrentValue = false, Flag = "AvoidOccupied", Callback = function(v) Config.AvoidOccupied = v end})
FarmingTab:CreateToggle({Name = "Fight Close Mobs", CurrentValue = false, Flag = "FightCloseMobs", Callback = function(v) Config.FightCloseMobs = v end})

FarmingTab:CreateSection("Zones")
local ZoneDropdown = FarmingTab:CreateDropdown({Name = "Select Mining Zones (Empty = All)", Options = {"Loading..."}, CurrentOption = {}, MultipleOptions = true, Flag = "MiningZones", Callback = function(options) Config.SelectedZones = options end})

task.spawn(function()
    while not ScriptAPI.GetZoneNames do task.wait(0.5) end
    local zones = ScriptAPI.GetZoneNames()
    if #zones > 0 then ZoneDropdown:Refresh(zones) end
end)

-- COMBAT SECTION
CombatTab:CreateSection("Auto Farm V2")
CombatTab:CreateToggle({
    Name = "Auto Farm V2 (might kick)", 
    CurrentValue = false, 
    Flag = "AutoFarmV2", 
    Callback = function(v) 
        Config.AutoFarmV2 = v 
    end
})
CombatTab:CreateToggle({Name = "Auto Fix Shop (On V2 Start)", CurrentValue = false, Flag = "AutoFixShop", Callback = function(v) Config.AutoFixShop = v end})

CombatTab:CreateSection("Standard Combat")
CombatTab:CreateToggle({Name = "Auto Attack", CurrentValue = false, Flag = "AutoAttack", Callback = function(v) Config.AutoAttack = v end})
CombatTab:CreateToggle({Name = "Auto Block", CurrentValue = false, Flag = "AutoParry", Callback = function(v) Config.AutoParry = v end})

CombatTab:CreateSection("Targets")
local SeenMobs = {}
task.spawn(function()
    while true do
        if ScriptAPI.GetMobTypes then
            for _, m in ipairs(ScriptAPI.GetMobTypes()) do
                if not SeenMobs[m] then
                    SeenMobs[m] = true
                    CombatTab:CreateToggle({Name = "Farm: "..m, CurrentValue = false, Flag = "Mob_"..m, Callback = function(v) Config.AttackTargets[m] = v end})
                end
            end
        end
        task.wait(5)
    end
end)

-- SELLING SECTION (DYNAMIC SELECTION)
SellingTab:CreateSection("Auto Sell Controls")
SellingTab:CreateToggle({Name = "Enable Auto Sell", CurrentValue = false, Flag = "AutoSell", Callback = function(v) Config.AutoSell = v end})
SellingTab:CreateButton({Name = "Talk to Buyer (Fixes Shop)", Callback = function() if ScriptAPI.TalkToSeller and ScriptAPI.TalkToSeller() then Rayfield:Notify({Title = "Success", Content = "Shop opened!", Duration = 3}) end end})

SellingTab:CreateSection("Item Selection (Detected in Inventory)")
local SellToggleCache = {}
task.spawn(function()
    while true do
        local inv = GetInventoryData()
        for itemName, _ in pairs(inv) do
            if not SellToggleCache[itemName] then
                SellToggleCache[itemName] = true
                SellingTab:CreateToggle({
                    Name = "Sell: " .. itemName,
                    CurrentValue = Config.SelectedSellItems[itemName] or false,
                    Callback = function(state)
                        Config.SelectedSellItems[itemName] = state
                    end
                })
            end
        end
        task.wait(3)
    end
end)

local MoneyLabel = SellingTab:CreateParagraph({Title = "Status", Content = "Checking..."})
task.spawn(function() while true do task.wait(2); if ScriptAPI.GetPlayerMoney then MoneyLabel:Set({Title = "Status", Content = "Cash: "..ScriptAPI.GetPlayerMoney()}) end end end)

-- FORGE SECTION (DYNAMIC SELECTION)
ForgeTab:CreateSection("Manual Forge Assist")
ForgeTab:CreateToggle({Name = "Auto Hammer Minigame (Manual)", CurrentValue = false, Flag = "AutoHammer", Callback = function(v) Config.AutoHammer = v end})
ForgeTab:CreateButton({Name = "Start Melt & Pour (Use Settings Below)", Callback = function() if ScriptAPI.ManualMeltAndPour then ScriptAPI.ManualMeltAndPour(function(t, m) Rayfield:Notify({Title = t, Content = m, Duration = 3}) end) end end})

ForgeTab:CreateSection("Item Selection (Detected Ores)")
local ForgeToggleCache = {}
task.spawn(function()
    while true do
        local inv = GetInventoryData()
        for itemName, _ in pairs(inv) do
            if not ForgeToggleCache[itemName] then
                ForgeToggleCache[itemName] = true
                ForgeTab:CreateToggle({
                    Name = "Use: " .. itemName,
                    CurrentValue = (Config.SelectedOre == itemName),
                    Callback = function(state)
                        if state then Config.SelectedOre = itemName end
                    end
                })
            end
        end
        task.wait(3)
    end
end)

ForgeTab:CreateSection("Genuine Auto Forge")
local OreStatusLabel = ForgeTab:CreateParagraph({Title = "Status", Content = "Loading Ores..."})
ForgeTab:CreateSlider({Name = "Quantity to Use", Range = {1, 100}, Increment = 1, Suffix = "Ores", CurrentValue = 1, Flag = "ForgeQty", Callback = function(v) Config.ForgeQty = v end})
ForgeTab:CreateDropdown({Name = "Item Type", Options = {"Weapon", "Armor"}, CurrentOption = {"Weapon"}, Flag = "ForgeItemType", Callback = function(o) Config.ForgeItemType = o[1] end})
task.spawn(function() while true do local av = GetInventoryData(); OreStatusLabel:Set({Title = "Inventory", Content = "Selected: "..Config.SelectedOre.."\nOwned: "..(av[Config.SelectedOre] or 0)}); task.wait(1) end end)
ForgeTab:CreateButton({Name = "Start Genuine Forge", Callback = function() if ScriptAPI.GenuineForge then local av = GetInventoryData(); local use = math.min(Config.ForgeQty, av[Config.SelectedOre] or 0); ScriptAPI.GenuineForge({[Config.SelectedOre]=use}, Config.ForgeItemType, function(t, m) Rayfield:Notify({Title = t, Content = m, Duration = 5}) end) end end})

-- TELEPORT SECTION
TeleportTab:CreateSection("Proximity Locations")
local function RefreshLocations()
    local pf = Workspace:FindFirstChild("Proximity")
    if not pf then return end
    for _, loc in ipairs(pf:GetChildren()) do
        if loc:IsA("Model") or loc:IsA("BasePart") then
            TeleportTab:CreateButton({Name = loc.Name, Callback = function()
                local tcf = loc:IsA("Model") and (loc.PrimaryPart and loc.PrimaryPart.CFrame or loc:GetPivot()) or loc.CFrame
                if tcf then TweenCharacterTo(tcf) end
            end})
        end
    end
end
RefreshLocations()

-- MISC SECTION
MiscTab:CreateSection("Character")
MiscTab:CreateToggle({Name = "Auto Run", CurrentValue = false, Flag = "AutoRun", Callback = function(v) Config.AutoRun = v end})
MiscTab:CreateToggle({Name = "Infinite Fly", CurrentValue = false, Flag = "InfiniteFly", Callback = function(v) Config.InfiniteFly = v end})
MiscTab:CreateToggle({Name = "Click TP (Ctrl+Click)", CurrentValue = false, Flag = "ClickTP", Callback = function(v) Config.ClickTeleport = v end})
MiscTab:CreateButton({Name = "Redeem All Codes", Callback = function() RedeemAllCodes(); Rayfield:Notify({Title = "Codes", Content = "Redeeming...", Duration = 3}) end})

print("[The Forge] Complete Script Loaded!")
Rayfield:LoadConfiguration()
